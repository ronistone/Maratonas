#include <bits/stdc++.h>
using namespace std;

typedef vector<vector<int> > vvi;
typedef vector<int> vi;
typedef vector<pair<int,int> > vii;
vvi Grafo(1005);
vii pontes;
int dfs_low[1005];
int dfs_num[1005];
int dfs_parent[1005];
bool articulation_vertex[1005];
int dfsNumberCounter,Children,dfsRoot,n,arti;
void print_dfs(){
	cout << pontes.size() << " critical links\n";
	for(int i=0;i<pontes.size();i++){
		cout << pontes[i].first << " - " << pontes[i].second << "\n";
	}
	cout << "\n";
}
void dfs(int u){
	dfs_low[u] = dfs_num[u] = dfsNumberCounter++;
	for(int i=0;i<Grafo[u].size();i++){
		int v = Grafo[u][i];
		if(dfs_num[v]==-1){
			dfs_parent[v] = u;
			if(u==dfsRoot)
				Children++;
			dfs(v);
			
			if(dfs_low[v]>=dfs_num[u]){
				articulation_vertex[u] = true;}
//			if(dfs_low[v]>dfs_num[u])
//				pontes.push_back(make_pair(u,v));
			dfs_low[u] = min(dfs_low[u],dfs_low[v]);
		}
		else if(v!=dfs_parent[u])
			dfs_low[u] = min(dfs_low[u],dfs_num[v]);
	}	
}
void reset(){
	for(int i=0;i<n;i++){
			Grafo[i].clear();
			dfs_num[i] = -1;
			dfs_low[i] = 0;
			dfs_parent[i] = 0;
			articulation_vertex[i] = false;
		}
		//pontes.clear();
		dfsNumberCounter = 0;
		arti = 0;
}
void solve(){
	for(int i=0;i<n;i++){
		if(dfs_num[i]==-1){
			dfsRoot = i;
			Children = 0;
			dfs(i);
			articulation_vertex[i] = (Children>1);
		}
	}
	for(int i=0;i<n;i++){
		if(articulation_vertex[i])
			arti++;
	}
	cout << arti << "\n";
}

main(){
	int i,j,k,from,to,m;

	while(cin >> n and n){
		reset();
		for(i=0;i<n+1;i++){
			cin >> from;
			if(from==0)
				break;
			while(cin >> to and to){
				Grafo[from-1].push_back(to-1);
				Grafo[to-1].push_back(from-1);
				if(getchar()=='\n')
					break;
			}
		}
		solve();
	}
}

/*#include <bits/stdc++.h>

using namespace std;
vector<vector<int> >grafo(105);
int n, root, rootChildren, counter, criticos;
vector<int> dfs_low, dfs_num, dfs_parent;
bool articulationVertex[105];

void points(int u)
{
    dfs_low[u] = dfs_num[u] = counter++;

    for (int i = 0; i < grafo[u].size(); i++)
    {
        int v = grafo[u][i];

        if (dfs_num[v] == -1)
        {
            dfs_parent[v] = u;
            if (u == root) rootChildren++;

            points(v);

            if (dfs_low[v] >= dfs_num[u])
                articulationVertex[u] = true;

            dfs_low[u] = min(dfs_low[u], dfs_low[v]);
        }
        else if (v != dfs_parent[u])
            dfs_low[u] = min(dfs_low[u], dfs_num[v]);
    }
}

void reset(int v)
{
    criticos = 0;
    counter = 0;
    dfs_num.assign(v+1, -1);
    dfs_low.assign(v+1, 0);
    dfs_parent.assign(v+1, 0);
    memset(articulationVertex, false, sizeof articulationVertex);
}

main()
{
    stringstream ss;
    string str;
    while(cin >> n && n)
    {
        for (int i = 0; i <= n; i++)
            grafo[i].clear();

        cin.ignore();

        while(getline(cin, str) && str != "0")
        {
            int vertice, num;
            ss.clear();
            ss << str;
            ss >> vertice;

            while(ss >> num)
            {
                grafo[vertice].push_back(num);
                grafo[num].push_back(vertice);
            }
        }

        reset(n);

        for (int i = 1; i <= n; i++)
        {
            if (dfs_num[i] == -1){
                root = i;
                rootChildren = 0;
                points(i);
                articulationVertex[i] = (rootChildren > 1);
            }
        }

        for (int i = 1; i <= n; i++)
            if (articulationVertex[i])
                criticos++;
        cout << criticos << endl;
    }
}*/

